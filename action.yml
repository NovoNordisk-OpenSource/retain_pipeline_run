name: 'Retain Pipeline Run'
description: >-
  Check for immutable releases configuration and create a release with all pipeline artifacts
author: 'Platform Engineering Team'

inputs:
  github_token:
    description: 'GitHub token with repository and release permissions'
    required: true
  release_tag:
    description: >-
      Tag for the release (if not provided, will be generated based on timestamp)
    required: false
  release_name:
    description: 'Name for the release (if not provided, will be generated)'
    required: false
  release_body:
    description: 'Description for the release'
    required: false
    default: 'Automated release created from pipeline run'
  prerelease:
    description: 'Mark this as a prerelease'
    required: false
    default: 'false'
  draft:
    description: 'Create as draft release'
    required: false
    default: 'false'

outputs:
  release_id:
    description: 'ID of the created release'
    value: ${{ steps.create_release.outputs.release_id }}
  release_url:
    description: 'URL of the created release'
    value: ${{ steps.create_release.outputs.html_url }}
  release_tag:
    description: 'Tag of the created release'
    value: ${{ steps.generate_release_info.outputs.release_tag }}
  immutable_releases_enabled:
    description: 'Whether immutable releases are enabled for this repository'
    value: ${{ steps.check_immutable.outputs.immutable_enabled }}
  artifacts_count:
    description: 'Number of artifacts attached to the release'
    value: ${{ steps.get_artifacts.outputs.artifact_count }}

runs:
  using: 'composite'
  steps:
    - name: Checkout retain-artifacts action
      uses: actions/checkout@v4
      with:
        repository: 'NovoNordisk-OpenSource/retain_pipeline_run'
        path: './.github/actions/retain-artifacts'

    - name: Setup GitHub CLI
      shell: bash
      run: |
        # Verify GitHub CLI is available
        # (pre-installed on GitHub Actions runners)
        if ! command -v gh >/dev/null 2>&1; then
          echo "Error: GitHub CLI not available on this runner"
          exit 1
        fi

        # Verify GitHub CLI is available and token is set
        export GITHUB_TOKEN="${{ inputs.github_token }}"

        # Set repository context for GitHub CLI
        gh repo set-default ${{ github.repository }}


    - name: Get all artifacts from current run
      id: get_artifacts
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        echo "Fetching artifacts from current pipeline run (${{ github.run_id }})..."

        # Get artifacts for the current run with error handling
        if ! ARTIFACTS_JSON=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts 2>&1); then
          echo "‚ùå Failed to fetch artifacts from GitHub API"
          echo "Error: $ARTIFACTS_JSON"
          echo ""
          echo "This may be due to insufficient permissions. The GITHUB_TOKEN needs:"
          echo "- actions: read (to access workflow artifacts)"
          echo "- contents: write (to create releases)"
          echo ""
          echo "üí° Note: Some organization repositories may have additional restrictions."
          echo "Consider using a personal access token with appropriate permissions."

          # Set empty artifacts for graceful continuation
          ARTIFACTS_JSON='{"total_count": 0, "artifacts": []}'
          echo "‚ö†Ô∏è Continuing with empty artifacts list..."
        fi

        # Extract artifact information
        ARTIFACT_COUNT=$(echo "$ARTIFACTS_JSON" | jq '.total_count')
        echo "Found $ARTIFACT_COUNT artifacts"

        if [ "$ARTIFACT_COUNT" -gt 0 ]; then
          # Save detailed artifact information
          echo "$ARTIFACTS_JSON" | jq '.artifacts[] | {
            name: .name,
            id: .id,
            size_in_bytes: .size_in_bytes,
            created_at: .created_at,
            updated_at: .updated_at,
            archive_download_url: .archive_download_url
          }' > ./.github/actions/retain-artifacts/artifacts_list.json

          echo "Artifacts list saved"

          # Create a summary of artifacts
          ARTIFACT_NAMES=$(echo "$ARTIFACTS_JSON" | jq -r '.artifacts[].name' | tr '\n' ', ' | sed 's/,$//')
          TOTAL_SIZE=$(echo "$ARTIFACTS_JSON" | jq '[.artifacts[].size_in_bytes] | add')

          echo "artifact_names=$ARTIFACT_NAMES" >> $GITHUB_OUTPUT
          echo "artifact_count=$ARTIFACT_COUNT" >> $GITHUB_OUTPUT
          echo "total_size_bytes=$TOTAL_SIZE" >> $GITHUB_OUTPUT

          # Human readable size
          if command -v numfmt >/dev/null 2>&1; then
            TOTAL_SIZE_HUMAN=$(numfmt --to=iec-i --suffix=B $TOTAL_SIZE)
          else
            TOTAL_SIZE_HUMAN="${TOTAL_SIZE} bytes"
          fi
          echo "total_size_human=$TOTAL_SIZE_HUMAN" >> $GITHUB_OUTPUT

          echo "Total artifacts size: $TOTAL_SIZE_HUMAN"
        else
          echo "No artifacts found in current run"
          echo "artifact_names=" >> $GITHUB_OUTPUT
          echo "artifact_count=0" >> $GITHUB_OUTPUT
          echo "total_size_bytes=0" >> $GITHUB_OUTPUT
          echo "total_size_human=0 bytes" >> $GITHUB_OUTPUT
        fi

    - name: Generate release information
      id: generate_release_info
      shell: bash
      run: |
        # Use current git tag or generate release tag if not provided
        if [ -z "${{ inputs.release_tag }}" ]; then
          # Try to get current git tag (e.g., v1.2.3)
          CURRENT_TAG=$(git describe --tags --exact-match 2>/dev/null || echo "")

          if [ -n "$CURRENT_TAG" ]; then
            RELEASE_TAG="$CURRENT_TAG"
            echo "‚úÖ Using current git tag: $RELEASE_TAG"
          else
            # Fallback to timestamp-based tag if no git tag exists
            TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
            RELEASE_TAG="pipeline-${{ github.run_id }}-$TIMESTAMP"
            echo "‚ö†Ô∏è No git tag found, using generated tag: $RELEASE_TAG"
          fi
        else
          RELEASE_TAG="${{ inputs.release_tag }}"
        fi

        # Generate release name if not provided
        if [ -z "${{ inputs.release_name }}" ]; then
          RELEASE_NAME="Pipeline Artifacts - Run #${{ github.run_id }}"
        else
          RELEASE_NAME="${{ inputs.release_name }}"
        fi

        # Get workflow job approvals information
        APPROVAL_INFO=""
        set +e

        echo "üîç Checking for approval information..."

        # Get workflow jobs for this run
        JOBS_DATA=$(gh api "repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" 2>/dev/null)

        if [ -n "$JOBS_DATA" ]; then
          # Look for validation approval job
          VALIDATION_JOB=$(echo "$JOBS_DATA" | jq -r '.jobs[] | select(.name == "verification_report_approval_by_so_or_delegate") | select(.conclusion == "success")' 2>/dev/null)

          # Look for production approval job
          PRODUCTION_JOB=$(echo "$JOBS_DATA" | jq -r '.jobs[] | select(.name == "p_verification_report_approval_by_so_or_delegate") | select(.conclusion == "success")' 2>/dev/null)

          # Get environment deployments for this workflow run
          DEPLOYMENTS=$(gh api "repos/${{ github.repository }}/deployments" --jq ".[] | select(.sha == \"${{ github.sha }}\") | select(.environment | test(\"System-Manager-Approval\"; \"i\"))" 2>/dev/null)

          # Process validation approval
          if [ -n "$VALIDATION_JOB" ] && [ -n "$DEPLOYMENTS" ]; then
            echo "  ‚úÖ Processing validation approval..."

            # Get deployment ID directly (no subshell)
            DEPLOYMENT_ID=$(echo "$DEPLOYMENTS" | jq -r '.id')
            if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ]; then
              echo "    üìã Checking deployment $DEPLOYMENT_ID"
              STATUSES=$(gh api "repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" 2>/dev/null)

              if [ -n "$STATUSES" ]; then
                # Extract approver and time directly (avoid broken JSON from head -1)
                APPROVER=$(echo "$STATUSES" | jq -r '.[] | select(.state == "success") | .creator.login' | head -1)
                APPROVAL_TIME=$(echo "$STATUSES" | jq -r '.[] | select(.state == "success") | .created_at' | head -1)

                if [ -n "$APPROVER" ] && [ "$APPROVER" != "null" ] && [ -n "$APPROVAL_TIME" ] && [ "$APPROVAL_TIME" != "null" ]; then
                    echo "    ‚úÖ Found validation approver: $APPROVER at $APPROVAL_TIME"
                    FORMATTED_TIME=$(date -d "$APPROVAL_TIME" -u '+%Y-%m-%d %H:%M:%S GMT' 2>/dev/null || echo "$APPROVAL_TIME")
                    echo "VALIDATION_APPROVER=$APPROVER" > /tmp/validation_approval
                    echo "VALIDATION_TIME=$FORMATTED_TIME" >> /tmp/validation_approval
                  fi
                fi
              fi
            fi
          fi

          # Process production approval
          if [ -n "$PRODUCTION_JOB" ] && [ -n "$DEPLOYMENTS" ]; then
            echo "  ‚úÖ Processing production approval..."

            # Get deployment ID directly (no subshell)
            DEPLOYMENT_ID=$(echo "$DEPLOYMENTS" | jq -r '.id')
            if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ]; then
              STATUSES=$(gh api "repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" 2>/dev/null)

              if [ -n "$STATUSES" ]; then
                # Extract approver and time directly for production (use tail -1 for later approval)
                APPROVER=$(echo "$STATUSES" | jq -r '.[] | select(.state == "success") | .creator.login' | tail -1)
                APPROVAL_TIME=$(echo "$STATUSES" | jq -r '.[] | select(.state == "success") | .created_at' | tail -1)

                if [ -n "$APPROVER" ] && [ "$APPROVER" != "null" ] && [ -n "$APPROVAL_TIME" ] && [ "$APPROVAL_TIME" != "null" ]; then
                    echo "    ‚úÖ Found production approver: $APPROVER at $APPROVAL_TIME"
                    FORMATTED_TIME=$(date -d "$APPROVAL_TIME" -u '+%Y-%m-%d %H:%M:%S GMT' 2>/dev/null || echo "$APPROVAL_TIME")
                    echo "PRODUCTION_APPROVER=$APPROVER" > /tmp/production_approval
                    echo "PRODUCTION_TIME=$FORMATTED_TIME" >> /tmp/production_approval
                  fi
                fi
              fi
            fi
          fi

          # Build approval information string
          if [ -f /tmp/validation_approval ]; then
            source /tmp/validation_approval
            APPROVAL_INFO="${APPROVAL_INFO}\n\nVerification report from the validation environment was approved by @${VALIDATION_APPROVER} as SO or Delegate at $VALIDATION_TIME"
            rm -f /tmp/validation_approval
          fi

          if [ -f /tmp/production_approval ]; then
            source /tmp/production_approval
            APPROVAL_INFO="${APPROVAL_INFO}\n\nVerification report from the production environment was approved by @${PRODUCTION_APPROVER} as SO or Delegate at $PRODUCTION_TIME"
            rm -f /tmp/production_approval
          fi
        fi

        set -e

        if [ -n "$APPROVAL_INFO" ]; then
          echo "‚úÖ Approval information captured"
        else
          echo "‚ÑπÔ∏è No approval information found"
        fi

        # Generate comprehensive release body using proper newlines
        RELEASE_BODY=$(printf "%s%s\n\n## üìã Pipeline Information\n- **Run ID:** [%s](%s)\n- **Commit:** [\`%s\`](%s)\n- **Branch:** \`%s\`\n- **Workflow:** \`%s\`\n- **Triggered by:** \`%s\`\n- **Actor:** @%s\n- **Created:** %s" \
          "${{ inputs.release_body }}" \
          "$APPROVAL_INFO" \
          "${{ github.run_id }}" \
          "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
          "${{ github.sha }}" \
          "${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}" \
          "${{ github.ref_name }}" \
          "${{ github.workflow }}" \
          "${{ github.event_name }}" \
          "${{ github.actor }}" \
          "$(date -u '+%Y-%m-%d %H:%M:%S UTC')")

        if [ "${{ steps.get_artifacts.outputs.artifact_count }}" -gt 0 ]; then
          RELEASE_BODY=$(printf "%s\n\n## üì¶ Artifacts (%s)\nThis release contains **%s** artifacts with a total size of **%s**:" \
            "$RELEASE_BODY" \
            "${{ steps.get_artifacts.outputs.artifact_count }}" \
            "${{ steps.get_artifacts.outputs.artifact_count }}" \
            "${{ steps.get_artifacts.outputs.total_size_human }}")

          # Add artifact list
          ARTIFACT_LIST=""
          if [ -f "./.github/actions/retain-artifacts/artifacts_list.json" ]; then
            while IFS= read -r artifact_info; do
              ARTIFACT_NAME=$(echo "$artifact_info" | jq -r '.name')
              ARTIFACT_SIZE=$(echo "$artifact_info" | jq -r '.size_in_bytes')

              # Convert size to human readable if possible
              if command -v numfmt >/dev/null 2>&1; then
                ARTIFACT_SIZE_HUMAN=$(numfmt --to=iec-i --suffix=B $ARTIFACT_SIZE)
              else
                ARTIFACT_SIZE_HUMAN="${ARTIFACT_SIZE} bytes"
              fi

              ARTIFACT_LIST=$(printf "%s\n- **%s** (%s)" "$ARTIFACT_LIST" "$ARTIFACT_NAME" "$ARTIFACT_SIZE_HUMAN")
            done < <(jq -c '.' ./.github/actions/retain-artifacts/artifacts_list.json)
          fi

          RELEASE_BODY=$(printf "%s%s\n\n> üíæ **Retention Period:** Indefinite (GitHub releases)" "$RELEASE_BODY" "$ARTIFACT_LIST")
        else
          RELEASE_BODY=$(printf "%s\n\n## üì¶ Artifacts\n‚ö†Ô∏è No artifacts were found in this pipeline run." "$RELEASE_BODY")
        fi

        # Add immutable release information from behavioral test
        IMMUTABLE_STATUS="${{ steps.test_immutable.outputs.immutable_enabled }}"
        IMMUTABLE_CONFIRMED="${{ steps.test_immutable.outputs.immutable_confirmed }}"

        if [ "$IMMUTABLE_CONFIRMED" = "true" ] || [ "$IMMUTABLE_STATUS" = "confirmed" ]; then
          IMMUTABLE_STATUS="confirmed"
        fi

        if [ "$IMMUTABLE_STATUS" = "confirmed" ]; then
          RELEASE_BODY=$(printf "%s\n\n## üîí Immutable Release Capability\n‚ö° **This repository has confirmed immutable releases enabled.**\n\n> **Immutable releases provide:**\n> ‚Ä¢ Git tags cannot be moved or deleted after publication\n> ‚Ä¢ Release assets cannot be modified or deleted\n> ‚Ä¢ Automatic generation of release attestations\n> ‚Ä¢ Protection against repository resurrection attacks\n>\n> Assessment: **%s** (confirmed through behavioral testing)\n>\n> üìñ [Learn more about immutable releases](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/immutable-releases)" \
            "$RELEASE_BODY" \
            "$IMMUTABLE_STATUS")
        elif [ "$IMMUTABLE_STATUS" = "not_enabled" ]; then
          RELEASE_BODY=$(printf "%s\n\n## üîí Release Integrity\nüõ°Ô∏è **This repository uses standard GitHub releases (mutable).**\n\n> Assessment: **%s** (confirmed through behavioral testing)\n>\n> üí° Consider enabling immutable releases for enhanced security and compliance." \
            "$RELEASE_BODY" \
            "$IMMUTABLE_STATUS")
        elif [ "$IMMUTABLE_STATUS" = "likely" ] || [ "$IMMUTABLE_STATUS" = "supported" ]; then
          RELEASE_BODY=$(printf "%s\n\n## üîí Immutable Release Capability\n‚ö° **This repository appears to support GitHub's immutable releases feature.**\n\n> **Immutable releases provide:**\n> ‚Ä¢ Git tags cannot be moved or deleted after publication\n> ‚Ä¢ Release assets cannot be modified or deleted\n> ‚Ä¢ Automatic generation of release attestations\n> ‚Ä¢ Protection against repository resurrection attacks\n>\n> Assessment: **%s** based on repository indicators\n>\n> üìñ [Learn more about immutable releases](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/immutable-releases)" \
            "$RELEASE_BODY" \
            "$IMMUTABLE_STATUS")
        elif [ "$IMMUTABLE_STATUS" = "unknown" ]; then
          RELEASE_BODY=$(printf "%s\n\n## üîí Release Integrity\nüõ°Ô∏è **This release provides standard GitHub release integrity.**\n\n> Immutable releases capability could not be determined for this repository." \
            "$RELEASE_BODY")
        fi

        # Add footer
        RELEASE_BODY=$(printf "%s\n\n---\n*ü§ñ This release was created automatically by the [retain_pipeline_run](https://github.com/NovoNordisk-OpenSource/retain_pipeline_run) action*" \
          "$RELEASE_BODY")

        # Set outputs
        echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
        echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT

        # Save release body to file for proper handling of newlines
        printf "%s" "$RELEASE_BODY" > ./.github/actions/retain-artifacts/release_body.txt
        echo "release_body_file=./.github/actions/retain-artifacts/release_body.txt" >> $GITHUB_OUTPUT

    - name: Download all artifacts
      id: download_artifacts
      if: steps.get_artifacts.outputs.artifact_count > 0
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        echo "üì• Downloading all artifacts for release creation..."

        # Create temporary directory for artifacts
        TEMP_DIR=$(mktemp -d)
        echo "üìÇ Created temp directory: $TEMP_DIR"

        DOWNLOADED_FILES=()

        # Read artifacts list and download each one
        if [ -f "$GITHUB_WORKSPACE/.github/actions/retain-artifacts/artifacts_list.json" ]; then
          while IFS= read -r artifact_info; do
            ARTIFACT_NAME=$(echo "$artifact_info" | jq -r '.name')
            ARTIFACT_ID=$(echo "$artifact_info" | jq -r '.id')

            echo "üì¶ Downloading artifact: $ARTIFACT_NAME (ID: $ARTIFACT_ID)"

            # Download artifact to temp directory
            ARTIFACT_FILE="$TEMP_DIR/${ARTIFACT_NAME}.zip"
            if gh api repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip > "$ARTIFACT_FILE" 2>/dev/null; then
              echo "  ‚úÖ Downloaded: ${ARTIFACT_NAME}.zip ($(ls -lh "$ARTIFACT_FILE" | awk '{print $5}'))"
              DOWNLOADED_FILES+=("$ARTIFACT_FILE")
            else
              echo "  ‚ùå Failed to download artifact: $ARTIFACT_NAME"
            fi

          done < <(jq -c '.' "$GITHUB_WORKSPACE/.github/actions/retain-artifacts/artifacts_list.json")
        fi

        echo "üìä Download Summary: ${#DOWNLOADED_FILES[@]} artifacts downloaded"

        # Set outputs
        echo "temp_dir=$TEMP_DIR" >> $GITHUB_OUTPUT
        echo "downloaded_count=${#DOWNLOADED_FILES[@]}" >> $GITHUB_OUTPUT

        # Create file list for release creation
        printf '%s\n' "${DOWNLOADED_FILES[@]}" > "$TEMP_DIR/artifact_files.txt"

    - name: Create release with artifacts
      id: create_release
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        echo "Creating release with artifacts: ${{ steps.generate_release_info.outputs.release_name }}"

        # Read release body from file
        RELEASE_BODY=$(cat ${{ steps.generate_release_info.outputs.release_body_file }})

        # Prepare base release creation command arguments
        RELEASE_ARGS=(
          "${{ steps.generate_release_info.outputs.release_tag }}"
          "--title" "${{ steps.generate_release_info.outputs.release_name }}"
          "--notes" "$RELEASE_BODY"
        )

        if [ "${{ inputs.prerelease }}" = "true" ]; then
          RELEASE_ARGS+=("--prerelease")
        fi

        if [ "${{ inputs.draft }}" = "true" ]; then
          RELEASE_ARGS+=("--draft")
        fi

        # Add all downloaded artifacts to the release creation
        if [ "${{ steps.download_artifacts.outputs.downloaded_count }}" -gt 0 ]; then
          echo "üìé Creating release with ${{ steps.download_artifacts.outputs.downloaded_count }} artifacts attached..."

          # Read downloaded file paths and add to release creation
          if [ -f "${{ steps.download_artifacts.outputs.temp_dir }}/artifact_files.txt" ]; then
            while IFS= read -r artifact_file; do
              if [ -f "$artifact_file" ]; then
                RELEASE_ARGS+=("$artifact_file")
                echo "  üìé Adding artifact: $(basename "$artifact_file")"
              fi
            done < "${{ steps.download_artifacts.outputs.temp_dir }}/artifact_files.txt"
          fi
        else
          echo "üì¶ Creating release without artifacts (none found in pipeline)"
        fi

        # Create the release
        if gh release create "${RELEASE_ARGS[@]}"; then
          echo "‚úÖ Release created successfully"

          # Get release information
          RELEASE_INFO=$(gh release view "${{ steps.generate_release_info.outputs.release_tag }}" --json id,url)
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          RELEASE_URL=$(echo "$RELEASE_INFO" | jq -r '.url')

          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "html_url=$RELEASE_URL" >> $GITHUB_OUTPUT

          echo "Release ID: $RELEASE_ID"
          echo "Release URL: $RELEASE_URL"

          # Mark that artifacts were attached during creation
          echo "artifacts_attached_during_creation=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Failed to create release"
          exit 1
        fi

    - name: Test for immutable releases (behavioral detection)
      id: test_immutable
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        echo "üîç Testing release for immutable releases capability..."

        IMMUTABLE_CONFIRMED=false
        RELEASE_TAG="${{ steps.generate_release_info.outputs.release_tag }}"

        # Create a small test file to upload
        echo "immutable_test_$(date +%s)" > immutable-test-file.txt

        # Attempt to upload test file to the main release - this will fail with HTTP 422 if immutable
        echo "  üîÑ Testing asset upload to detect immutability on release: $RELEASE_TAG"
        set +e  # Temporarily disable exit on error for upload test
        UPLOAD_OUTPUT=$(gh release upload "$RELEASE_TAG" immutable-test-file.txt 2>&1)
        UPLOAD_EXIT_CODE=$?
        set -e  # Re-enable exit on error

        if [ $UPLOAD_EXIT_CODE -eq 0 ]; then
          echo "  ‚úÖ Test file upload successful - releases are mutable"
          IMMUTABLE_CONFIRMED=false
          # Update detection to reflect confirmed mutable status
          echo "immutable_enabled=not_enabled" >> $GITHUB_OUTPUT
          echo "immutable_reasons=behavioral_test_mutable" >> $GITHUB_OUTPUT

          # Clean up the uploaded test file (possible in mutable releases)
          echo "  üßπ Cleaning up test file from mutable release..."
          set +e  # Allow cleanup to fail without stopping the workflow
          gh release delete-asset "$RELEASE_TAG" immutable-test-file.txt 2>/dev/null || echo "  ‚ö†Ô∏è Could not delete test file asset"
          set -e
        else
          echo "  üìù Upload failed, checking error:"
          echo "$UPLOAD_OUTPUT" | sed 's/^/     /'

          if echo "$UPLOAD_OUTPUT" | grep -q "Cannot upload assets to an immutable release"; then
            echo "  üîí CONFIRMED: Repository has immutable releases enabled!"
            IMMUTABLE_CONFIRMED=true
            # Update the previous detection
            echo "immutable_enabled=confirmed" >> $GITHUB_OUTPUT
            echo "immutable_reasons=behavioral_test_immutable" >> $GITHUB_OUTPUT
          else
            echo "  ‚ùå Upload failed for other reasons (not immutable releases)"
            echo "immutable_enabled=unknown" >> $GITHUB_OUTPUT
            echo "immutable_reasons=behavioral_test_failed" >> $GITHUB_OUTPUT
          fi
        fi

        # Clean up local test file
        rm -f immutable-test-file.txt

        # Set outputs
        echo "immutable_confirmed=$IMMUTABLE_CONFIRMED" >> $GITHUB_OUTPUT

        if [ "$IMMUTABLE_CONFIRMED" = "true" ]; then
          echo "‚úÖ Immutable releases confirmed through behavioral testing"
        elif [ "$IMMUTABLE_CONFIRMED" = "false" ]; then
          echo "‚úÖ Mutable releases confirmed through behavioral testing"
        else
          echo "‚ö†Ô∏è Unable to determine release mutability through testing"
        fi


    - name: Cleanup temporary files
      if: always()
      shell: bash
      run: |
        # Clean up temporary directory if it was created
        if [ -n "${{ steps.download_artifacts.outputs.temp_dir }}" ] && [ -d "${{ steps.download_artifacts.outputs.temp_dir }}" ]; then
          echo "üßπ Cleaning up temporary directory: ${{ steps.download_artifacts.outputs.temp_dir }}"
          rm -rf "${{ steps.download_artifacts.outputs.temp_dir }}"
        fi

    - name: Generate action summary
      shell: bash
      run: |
        echo "## üöÄ Retain Artifacts Action - Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| **Release Tag** | \`${{ steps.generate_release_info.outputs.release_tag }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Release Name** | ${{ steps.generate_release_info.outputs.release_name }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Release URL** | [${{ steps.create_release.outputs.html_url }}](${{ steps.create_release.outputs.html_url }}) |" >> $GITHUB_STEP_SUMMARY
        echo "| **Artifacts Count** | ${{ steps.get_artifacts.outputs.artifact_count }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Total Size** | ${{ steps.get_artifacts.outputs.total_size_human }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Immutable Releases** | ${{ steps.test_immutable.outputs.immutable_enabled }} |" >> $GITHUB_STEP_SUMMARY

        if [ "${{ steps.get_artifacts.outputs.artifact_count }}" -gt 0 ]; then
          echo "| **Attachment Method** | Attached during release creation |" >> $GITHUB_STEP_SUMMARY
          echo "| **Successful Attachments** | ${{ steps.download_artifacts.outputs.downloaded_count }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Failed Attachments** | 0 |" >> $GITHUB_STEP_SUMMARY
        fi

        echo "" >> $GITHUB_STEP_SUMMARY

        if [ "${{ steps.get_artifacts.outputs.artifact_count }}" -gt 0 ]; then
          echo "### üì¶ Attached Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.get_artifacts.outputs.artifact_names }}" | tr ',' '\n' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi

        echo "‚úÖ **Release created successfully with all available pipeline artifacts retained!**" >> $GITHUB_STEP_SUMMARY

        # Ensure success exit code
        exit 0

branding:
  icon: 'archive'
  color: 'blue'

